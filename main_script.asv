%% Main Script
% Darius Irani
clc; clear all;

%% Defining Variables
% User specifies number of robots
numRobots = input('Enter the number of robots: ');

% gets user specified boundary coordinates from function
[boundaryX, boundaryY, obstacleCenters, obstacleRadii] = get_boundary();
boundaryX = [boundaryX; boundaryX(1)];
boundaryY = [boundaryY; boundaryY(1)];

% initialize random robot position in the room
robot_positions = get_robot_positions(boundaryX, boundaryY, obstacleCenters, obstacleRadii, numRobots);

% plot the inititial setup
plot_initial_setup(boundaryX, boundaryY, obstacleCenters, obstacleRadii, robot_positions);

% Define grid over workspace
x = linspace(min(boundaryX), max(boundaryX), 200);
y = linspace(min(boundaryY), max(boundaryY), 200);
[X, Y] = meshgrid(x, y);

%% Defining Functions
% defining variables
kappa = 3.5;

% Define obstacle function
beta_sphere = struct([]);
for i = 1:length(obstacleRadii)
    % Obstacle repulsion field for each obstacle
    beta_sphere(i).obsfn = ((X - obstacleCenters(i, 1)).^2 + ...
                            (Y - obstacleCenters(i, 2)).^2) - ...
                            obstacleRadii(i)^2;
end
beta_prod = ones(size(beta_sphere(1).obsfn));
for i = 1:length(beta_sphere)
    beta_prod = beta_prod .* beta_sphere(i).obsfn;
end

% defining navigation function
% Define navigation function parameters
qd = [0, 0]; % Set goal point or central point (can be adjusted)
kappa = 3.5; % Controls the sharpness of the boundary approach

% Compute distance-to-goal function (gamma)
gamma = (X - qd(1)).^2 + (Y - qd(2)).^2;

% Construct the navigation function (combines attractive and repulsive fields)
nav = gamma ./ (gamma.^kappa + beta_prod) .^ (1/kappa);
